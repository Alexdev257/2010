<!DOCTYPE html>
<html>
<head>
    <title>Ch√∫c m·ª´ng 20/10 - Ng√†y Ph·ª• n·ªØ Vi·ªát Nam</title>
    <meta charset="UTF-8">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Quicksand:wght@300;500&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); overflow: hidden; font-family: 'Quicksand', sans-serif; }
        canvas { display: block; }
        .particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .particle { position: absolute; background: rgba(255, 255, 255, 0.6); border-radius: 50%; animation: float 8s infinite ease-in-out; }
        @keyframes float {
            0%, 100% { transform: translateY(0) translateX(0) scale(1); opacity: 0.3; }
            50% { transform: translateY(-100px) translateX(50px) scale(1.2); opacity: 0.8; }
        }
        #messageOverlay { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); text-align: center; z-index: 100; pointer-events: none; opacity: 0; animation: fadeInUp 1.5s ease-out forwards; animation-delay: 4s; }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateX(-50%) translateY(30px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        #messageOverlay h1 { font-family: 'Dancing Script', cursive; font-size: 3.5em; color: #fff; text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 182, 193, 0.6); margin-bottom: 10px; animation: glow 2s ease-in-out infinite; }
        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 182, 193, 0.6); }
            50% { text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 60px rgba(255, 182, 193, 0.9); }
        }
        #messageOverlay p { font-size: 1.3em; color: #fff; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); font-weight: 300; letter-spacing: 2px; }
        #messageOverlay h3 { font-size: 1.3em; color: #fff; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); font-weight: 300; letter-spacing: 2px; }
        #controls { position: fixed; bottom: 30px; right: 30px; background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); padding: 20px; border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.3); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); z-index: 10; transition: all 0.3s ease; }
        #controls:hover { background: rgba(255, 255, 255, 0.25); transform: translateY(-5px); }
        #controls label { display: block; color: #fff; font-size: 0.9em; margin-bottom: 10px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
        #controls input[type="range"] { width: 150px; cursor: pointer; -webkit-appearance: none; height: 6px; background: rgba(255, 255, 255, 0.3); border-radius: 3px; outline: none; }
        #controls input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); }
        .heart { position: fixed; font-size: 20px; color: #ff69b4; animation: floatHeart 4s ease-in-out infinite; pointer-events: none; z-index: 2; opacity: 0; }
        @keyframes floatHeart {
            0% { transform: translateY(100vh) scale(0) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100px) scale(1.5) rotate(360deg); opacity: 0; }
        }
        #instruction { position: fixed; top: 30px; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(10px); padding: 15px 30px; border-radius: 30px; color: #fff; font-size: 0.9em; border: 1px solid rgba(255, 255, 255, 0.3); z-index: 10; animation: pulse 2s ease-in-out infinite; }
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    <div id="messageOverlay">
        <h1>Ch√∫c m·ª´ng 20/10</h1>
        <p>Ng√†y Ph·ª• n·ªØ Vi·ªát Nam</p>
        <h3 style="font-weight: bold;">Ch√∫c m·ªçi ƒëi·ªÅu t·ªët ƒë·∫πp s·∫Ω t·ªõi v·ªõi b·∫°n ^^</h3>
    </div>
    
    <div id="controls" style="display: none;">
        <label>üîç Zoom</label>
        <input type="range" id="zoom" min="3" max="12" step="0.1" value="7">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Create particles
        const particlesContainer = document.getElementById('particles');
        for(let i = 0; i < 30; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = Math.random() * 4 + 2 + 'px';
            particle.style.height = particle.style.width;
            particle.style.left = Math.random() * 100 + '%';
            particle.style.top = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 8 + 's';
            particle.style.animationDuration = Math.random() * 5 + 5 + 's';
            particlesContainer.appendChild(particle);
        }
        // Create floating hearts
        function createHeart() {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = '‚ù§Ô∏è';
            heart.style.left = Math.random() * 100 + '%';
            heart.style.animationDuration = Math.random() * 2 + 3 + 's';
            heart.style.fontSize = Math.random() * 20 + 15 + 'px';
            document.body.appendChild(heart);
            setTimeout(() => { heart.remove(); }, 5000);
        }
        setInterval(createHeart, 1000);

        // Three.js Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x667eea);
        scene.fog = new THREE.Fog(0x667eea, 5, 15);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        let cameraDistance = 5;
        camera.position.set(cameraDistance, -cameraDistance, cameraDistance);
        camera.lookAt(0, 0, 0);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const mainLight = new THREE.DirectionalLight(0xfff5e1, 1.2);
        mainLight.position.set(3, 4, 2);
        mainLight.castShadow = true;
        scene.add(mainLight);
        const fillLight = new THREE.DirectionalLight(0xffb6c1, 0.8);
        fillLight.position.set(-2, -2, 2);
        scene.add(fillLight);
        const backLight = new THREE.DirectionalLight(0xe6e6fa, 0.6);
        backLight.position.set(0, -3, -2);
        scene.add(backLight);
        const pointLight1 = new THREE.PointLight(0xffd700, 0.5, 10);
        pointLight1.position.set(2, 2, 2);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0xff69b4, 0.5, 10);
        pointLight2.position.set(-2, 2, 2);
        scene.add(pointLight2);
        
        // Zoom control
        const zoomSlider = document.getElementById('zoom');
        zoomSlider.addEventListener('input', (e) => {
            cameraDistance = 15 - parseFloat(e.target.value);
            const currentPos = camera.position.clone().normalize();
            camera.position.copy(currentPos.multiplyScalar(cameraDistance));
            camera.lookAt(0, 0, 0);
        });

        // === THAY ƒê·ªîI 1: V√î HI·ªÜU H√ìA T∆Ø∆†NG T√ÅC CHU·ªòT ===
        // To√†n b·ªô kh·ªëi m√£ n√†y ƒë√£ ƒë∆∞·ª£c v√¥ hi·ªáu h√≥a ƒë·ªÉ ng∆∞·ªùi d√πng kh√¥ng th·ªÉ xoay b√≥ hoa
        /*
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mousemove', (e) => {
            if(!isDragging) return;
            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };
            const rotationSpeed = 0.005;
            scene.rotation.y += deltaMove.x * rotationSpeed;
            scene.rotation.x += deltaMove.y * rotationSpeed;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        */

        // Helper functions
        function meshgrid(x, y) {
            const X = [], Y = [];
            for(let i = 0; i < y.length; i++) {
                const row_x = [], row_y = [];
                for(let j = 0; j < x.length; j++) {
                    row_x.push(x[j]);
                    row_y.push(y[i]);
                }
                X.push(row_x);
                Y.push(row_y);
            }
            return [X, Y];
        }
        function createStem(startPoint) {
            const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(startPoint.x, startPoint.y, 0.4), 
                new THREE.Vector3(startPoint.x * 0.7, startPoint.y * 0.7, -0.6), 
                new THREE.Vector3(startPoint.x * 0.4, startPoint.y * 0.4, -1.3), 
                new THREE.Vector3(0, 0, -2.2)
             );
            const points = curve.getPoints(50);
            const geometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(points),
                50, 0.025, 8, false
            );
            const material = new THREE.MeshPhongMaterial({
                color: 0x2d5016,
                shininess: 40,
                specular: 0x444444
            });
            return new THREE.Mesh(geometry, material);
        }
        
        // Create wrapper paper
        function createWrapper() {
            const wrapperGroup = new THREE.Group();
            const radiusTop = 1.5, radiusBottom = 0.25, height = 2.3, radialSegments = 32;
            const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, 1, true);
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#FFE5F0');
            gradient.addColorStop(0.3, '#FFD6E8');
            gradient.addColorStop(0.6, '#FFC7E0');
            gradient.addColorStop(1, '#FFB8D8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for(let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 3 + 1;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 2;
            for(let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 512, 0);
                ctx.lineTo(Math.random() * 512, 512);
                ctx.stroke();
            }
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                shininess: 30
            });
            const wrapper = new THREE.Mesh(geometry, material);
            wrapper.position.z = -0.8;
            wrapper.rotation.x = Math.PI / 2;
            wrapperGroup.add(wrapper);
            const ribbonGeometry = new THREE.TorusGeometry(0.35, 0.08, 16, 32);
            const ribbonMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFD700,
                shininess: 100,
                specular: 0xFFFFFF
            });
            const ribbon = new THREE.Mesh(ribbonGeometry, ribbonMaterial);
            ribbon.position.z = -2.0;
            ribbon.rotation.x = Math.PI / 2;
            wrapperGroup.add(ribbon);
            const bowGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const bowMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFD700,
                shininess: 100
            });
            const bow1 = new THREE.Mesh(bowGeometry, bowMaterial);
            bow1.position.set(0.3, 0, -2.0);
            bow1.scale.set(1, 0.5, 0.3);
            wrapperGroup.add(bow1);
            const bow2 = new THREE.Mesh(bowGeometry, bowMaterial);
            bow2.position.set(-0.3, 0, -2.0);
            bow2.scale.set(1, 0.5, 0.3);
            wrapperGroup.add(bow2);
            return wrapperGroup;
        }
        function createRoseSurface() {
            const x = Array.from({length: 30}, (_, i) => i / 29);
            const t = Array.from({length: 1201}, (_, i) => (i * 0.5 / 600) * 20 * Math.PI + 4 * Math.PI);
            const [xr, tr] = meshgrid(x, t);
            const rows = tr.length, cols = tr[0].length;
            const pr = tr.map(row => row.map(t => (Math.PI/2) * Math.exp(-t/(8*Math.PI))));
            const cr = tr.map(row => row.map(t => Math.sin(15*t)/150));
            const ur = tr.map((row, i) => row.map((t, j) => {
                const mod_term = (3.6 * t) % (2 * Math.PI);
                return 1 - Math.pow(1 - mod_term/Math.PI, 4)/2 + cr[i][j];
            }));
            const yr = xr.map((row, i) => row.map((x, j) => 2 * Math.pow(x*x - x, 2) * Math.sin(pr[i][j])));
            const rr = xr.map((row, i) => row.map((x, j) => ur[i][j] * (x * Math.sin(pr[i][j]) + yr[i][j] * Math.cos(pr[i][j]))));
            const hr = xr.map((row, i) => row.map((x, j) => ur[i][j] * (x * Math.cos(pr[i][j]) - yr[i][j] * Math.sin(pr[i][j]))));
            const geometry = new THREE.BufferGeometry();
            const vertices = [], colors = [];
            let indices = [], index = 0;
            const colorList = [ [0.8, 0.1, 0.2], [0.95, 0.2, 0.3], [1.0, 0.4, 0.45], [1.0, 0.55, 0.6], [1.0, 0.7, 0.75], [1.0, 0.85, 0.88] ];
            let minH = Math.min(...hr.map(row => Math.min(...row)));
            let maxH = Math.max(...hr.map(row => Math.max(...row)));
            for(let i = 0; i < rows - 1; i++) {
                for(let j = 0; j < cols - 1; j++) {
                    const x1 = rr[i][j] * Math.cos(tr[i][j]), y1 = rr[i][j] * Math.sin(tr[i][j]), z1 = hr[i][j] + 0.35;
                    const x2 = rr[i+1][j] * Math.cos(tr[i+1][j]), y2 = rr[i+1][j] * Math.sin(tr[i+1][j]), z2 = hr[i+1][j] + 0.35;
                    const x3 = rr[i][j+1] * Math.cos(tr[i][j+1]), y3 = rr[i][j+1] * Math.sin(tr[i][j+1]), z3 = hr[i][j+1] + 0.35;
                    vertices.push(x1, y1, z1, x2, y2, z2, x3, y3, z3);
                    indices.push(index, index + 1, index + 2);
                    index += 3;
                    [hr[i][j], hr[i+1][j], hr[i][j+1]].forEach(h => {
                        const t = (h - minH) / (maxH - minH);
                        const colorIndex = Math.min(Math.floor(t * (colorList.length - 1)), colorList.length - 2);
                        const colorT = (t * (colorList.length - 1)) - colorIndex;
                        const color1 = colorList[colorIndex], color2 = colorList[colorIndex + 1];
                        colors.push(color1[0] * (1 - colorT) + color2[0] * colorT, color1[1] * (1 - colorT) + color2[1] * colorT, color1[2] * (1 - colorT) + color2[2] * colorT);
                    });
                    const x4 = rr[i+1][j+1] * Math.cos(tr[i+1][j+1]), y4 = rr[i+1][j+1] * Math.sin(tr[i+1][j+1]), z4 = hr[i+1][j+1] + 0.35;
                    vertices.push(x2, y2, z2, x4, y4, z4, x3, y3, z3);
                    indices.push(index, index + 1, index + 2);
                    index += 3;
                    [hr[i+1][j], hr[i+1][j+1], hr[i][j+1]].forEach(h => {
                        const t = (h - minH) / (maxH - minH);
                        const colorIndex = Math.min(Math.floor(t * (colorList.length - 1)), colorList.length - 2);
                        const colorT = (t * (colorList.length - 1)) - colorIndex;
                        const color1 = colorList[colorIndex], color2 = colorList[colorIndex + 1];
                        colors.push(color1[0] * (1 - colorT) + color2[0] * colorT, color1[1] * (1 - colorT) + color2[1] * colorT, color1[2] * (1 - colorT) + color2[2] * colorT);
                    });
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 80,
                specular: 0x666666,
                transparent: true,
                opacity: 0.95
            });
            return new THREE.Mesh(geometry, material);
        }
        function createBouquet() {
            const bouquetGroup = new THREE.Group();
            const positions = [
                { x: 0, y: 0, z: 0, scale: 1.05, rotate: 0 }, { x: 0.85, y: 0, z: 0, scale: 0.98, rotate: 0.2 },
                { x: -0.85, y: 0, z: 0.1, scale: 0.98, rotate: -0.2 }, { x: 0.45, y: 0.75, z: 0.05, scale: 0.96, rotate: 0.15 },
                { x: -0.35, y: 0.85, z: 0, scale: 0.96, rotate: -0.15 }, { x: 0.45, y: -0.75, z: 0.05, scale: 0.96, rotate: 0.15 },
                { x: -0.45, y: -0.75, z: 0, scale: 0.96, rotate: -0.15 }, { x: 0.6, y: 0.4, z: -0.1, scale: 0.92, rotate: 0.1 },
                { x: -0.6, y: -0.4, z: -0.1, scale: 0.92, rotate: -0.1 }
            ];
            positions.forEach((pos) => {
                const rose = createRoseSurface();
                rose.position.set(pos.x, pos.y, pos.z);
                rose.scale.set(pos.scale, pos.scale, pos.scale);
                if (pos.x !== 0 || pos.y !== 0) {
                    const distance = Math.sqrt(pos.x * pos.x + pos.y * pos.y);
                    const tiltAmount = 0.25;
                    rose.rotation.x = -pos.y * tiltAmount / distance;
                    rose.rotation.y = pos.x * tiltAmount / distance;
                }
                rose.rotation.z = pos.rotate;
                const stem = createStem(pos);
                bouquetGroup.add(rose);
                bouquetGroup.add(stem);
            });
            const wrapper = createWrapper();
            bouquetGroup.add(wrapper);
            return bouquetGroup;
        }
        const bouquet = createBouquet();
        scene.add(bouquet);

        // Animation phases
        let animationStartTime = Date.now();
        const phase1Duration = 3500;
        const phase2Duration = 2000;
        const initialScale = 0.01;
        const targetScale = 1.25;
        const initialRotationY = -Math.PI / 3;
        const targetRotationY = Math.PI / 3;
        let currentPhase = 1;
        let swayStartTime = 0;
        bouquet.scale.set(initialScale, initialScale, initialScale);
        bouquet.rotation.y = initialRotationY;
        function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
        function easeInOutSine(t) { return -(Math.cos(Math.PI * t) - 1) / 2; }
        
        function animate() {
            requestAnimationFrame(animate);
            const elapsed = Date.now() - animationStartTime;
            if (currentPhase === 1) {
                // Phase 1: Scale up and rotate
                const progress = Math.min(elapsed / phase1Duration, 1);
                const easedProgress = easeOutCubic(progress);
                const currentScale = initialScale + (targetScale - initialScale) * easedProgress;
                bouquet.scale.set(currentScale, currentScale, currentScale);
                const currentRotationY = initialRotationY + (targetRotationY - initialRotationY) * easedProgress;
                bouquet.rotation.y = currentRotationY;
                if (progress >= 1) {
                    currentPhase = 2;
                }
            } 
            // === THAY ƒê·ªîI 2: X√ìA CHUY·ªÇN ƒê·ªòNG L·∫ÆC L∆Ø ===
            // Logic cho phase 2 ƒë√£ ƒë∆∞·ª£c x√≥a b·ªè. B√≥ hoa s·∫Ω ƒë·ª©ng y√™n.
            // else if (currentPhase === 2 && !isDragging) { ... }
            
            // Animate point lights
            const time = Date.now() * 0.001;
            pointLight1.position.x = Math.cos(time) * 3;
            pointLight1.position.z = Math.sin(time) * 3;
            pointLight2.position.x = Math.cos(time + Math.PI) * 3;
            pointLight2.position.z = Math.sin(time + Math.PI) * 3;
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>